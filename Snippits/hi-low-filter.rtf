{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fmodern\fcharset0 CourierNewPSMT;\f2\fmodern\fcharset0 Courier;
}
{\colortbl;\red255\green255\blue255;\red4\green46\blue109;\red251\green0\blue7;\red235\green235\blue235;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww17080\viewh21740\viewkind0
\deftab720

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat1 \clwWidth30935\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt160 \clpadl160 \clpadb160 \clpadr160 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f0\b\fs24 \cf0 \expnd0\expndtw0\kerning0
LP and HP filter
\b0 \
\
Type : \cf2 biquad, tweaked butterworth\cf0 \
References : \cf2 Posted by Patrice Tarrabia\cf0 \
Code : \
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f1\fs26 \cf2 r\'a0\'a0= rez amount, from sqrt(2) to ~ 0.1\
f\'a0\'a0= cutoff frequency\
(from ~0 Hz to SampleRate/2 - though many\
synths seem to filter only\'a0\'a0up to SampleRate/4)\
\
The filter algo:\
out(n) = a1 * in + a2 * in(n-1) + a3 * in(n-2) - b1*out(n-1) - b2*out(n-2)\
\
Lowpass:\
\'a0\'a0\'a0\'a0\'a0\'a0c = 1.0 / tan(pi * f / sample_rate);\
\
\'a0\'a0\'a0\'a0\'a0\'a0a1 = 1.0 / ( 1.0 + r * c + c * c);\
\'a0\'a0\'a0\'a0\'a0\'a0a2 = 2* a1;\
\'a0\'a0\'a0\'a0\'a0\'a0a3 = a1;\
\'a0\'a0\'a0\'a0\'a0\'a0b1 = 2.0 * ( 1.0 - c*c) * a1;\
\'a0\'a0\'a0\'a0\'a0\'a0b2 = ( 1.0 - r * c + c * c) * a1;\
\
Hipass:\
\'a0\'a0\'a0\'a0\'a0\'a0c = tan(pi * f / sample_rate);\
\
\'a0\'a0\'a0\'a0\'a0\'a0a1 = 1.0 / ( 1.0 + r * c + c * c);\
\'a0\'a0\'a0\'a0\'a0\'a0a2 = -2*a1;\
\'a0\'a0\'a0\'a0\'a0\'a0a3 = a1;\
\'a0\'a0\'a0\'a0\'a0\'a0b1 = 2.0 * ( c*c - 1.0) * a1;\
\'a0\'a0\'a0\'a0\'a0\'a0b2 = ( 1.0 - r * c + c * c) * a1;
\f0\fs24 \cf0 \
\
\
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f2\fs26 \cf0 \
LPF:        H(s) = 1 / (s^2 + s/Q + 1)\
\
            b0 =  (1 - cos(w0))/2\
            b1 =   1 - cos(w0)\
            b2 =  (1 - cos(w0))/2\
            a0 =   1 + alpha\
            a1 =  -2*cos(w0)\
            a2 =   1 - alpha\
\
\
\
HPF:        H(s) = s^2 / (s^2 + s/Q + 1)\
\
            b0 =  (1 + cos(w0))/2\
            b1 = -(1 + cos(w0))\
            b2 =  (1 + cos(w0))/2\
            a0 =   1 + alpha\
            a1 =  -2*cos(w0)\
            a2 =   1 - alpha\
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\
\
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f1\fs26 \cf3 First calculate the prewarped digital frequency: \
\
K = tan(Pi * Frequency / Samplerate); \
\
Now calc some intermediate variables: (see 'Factors of Polynoms' at http://en.wikipedia.org/wiki/Butterworth_filter, especially if you want a higher order like 48dB/Oct) \
a = 0.76536686473 * Q * K; \
b = 1.84775906502 * Q * K; \
\
K = K*K; (to optimize it a little bit) \
\
Calculate the first biquad: \
\
A0 = (K+a+1); \
A1 = 2*(1-K); \
A2 =(a-K-1); \
B0 = K; \
B1 = 2*B0; \
B2 = B0; \
\
Calculate the second biquad: \
\
A3 = (K+b+1); \
A4 = 2*(1-K); \
A5 = (b-K-1); \
B3 = K; \
B4 = 2*B3; \
B5 = B3; \
\
Then calculate the output as follows: \
\
Stage1 = B0*Input + State0; \
State0 = B1*Input + A1/A0*Stage1 + State1; \
State1 = B2*Input + A2/A0*Stage1; \
\
Output = B3*Stage1 + State2; \
State2 = B4*Stage1 + A4/A3*Output + State2; \
State3 = B5*Stage1 + A5/A3*Output;
\f0\fs24 \cf0 \
\
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat4 \clwWidth33055\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt100 \clpadl100 \clpadb100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap2\pardeftab720\partightenfactor0
\cf0 \

\f1\fs26 \cf2 public class LowPassFilter\
\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// <summary>\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// rez amount, from sqrt(2) to ~ 0.1\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// </summary>\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float r;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// <summary>\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// cutoff frequency\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// (from ~0 Hz to SampleRate/2 - though many\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0/// synths seem to filter only up to SampleRate/4)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0///</summary>\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float f;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float c;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float a1;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float a2;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float a3;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float b1;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float b2;\
\
//\'a0\'a0\'a0\'a0\'a0\'a0float in0 = 0;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float in1 = 0;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float in2 = 0;\
\
//\'a0\'a0\'a0\'a0\'a0\'a0float out0;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float out1 = 0;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float out2 = 0;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0private int _SampleRate;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public LowPassFilter(int sampleRate)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0_SampleRate = sampleRate;\
\
//\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0SetParams(_SampleRate / 2f, 0.1f);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0SetParams(_SampleRate / 8f, 1f);\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0public float Process(float input)\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\{\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0float output = a1 * input + \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a2 * in1 + \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 a3 * in2 - \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 b1 * out1 - \
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 b2 * out2;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0in2 = in1;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0in1 = input;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0out2 = out1;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0out1 = output;\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0Console.WriteLine(input + ", " + output);\
\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0return output;\
\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\}\
\nestcell \lastrow\nestrow
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\
\
\
low pass\
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat4 \clwWidth33055\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt100 \clpadl100 \clpadb100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap2\pardeftab720\partightenfactor0
\cf0 \

\f1\fs26 \cf2 You can save two divisions for lowpass using \
\'a0\'a0c = tan((0.5 - (f * inv_samplerate))*pi);\
instead of\
\'a0\'a0c = 1.0 / tan(pi * f / sample_rate);\
where inv_samplerate is 1.0/samplerate precalculated. (mul is faster than div)\
\
However, the latter form can be approximated very well below 4kHz (at 44kHz samplerate) with \
\'a0\'a0c = 1.0 / (pi * f * inv_sample_rate);\
which is far better than both of the previous two equations, because it does not use any transcendental functions. So, an optimized form is:\
\
f0 = f * inv_sample_rate;\
if (f0 < 0.1) c = 1.0 / (f0 * pi); // below 4.4k\
else c = tan((0.5 - f0) * pi);\
\
This needs only about ~60% CPU below 4.4kHz. Probably using lookup tables could make it even faster...\
\
Mapping resonance range 0..1 to 0..self-osc:\
\'a0\'a0float const sqrt_two = 1.41421356;\
\'a0\'a0r = sqrt_two - resonance * sqrt_two;\
\
Setting resonance in the conventional q form (like in RBJ biquads):\
\'a0\'a0r = 1.0/q;\
\
Cheers, Peter\nestcell \lastrow\nestrow
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\
\
hi pass\
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat4 \clwWidth33055\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt100 \clpadl100 \clpadb100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap2\pardeftab720\partightenfactor0
\cf0 \

\f1\fs26 \cf2 You can use the same trick for highpass:\
\
precalc when setting up the filter:\
\'a0\'a0inv_samplerate = 1.0 / samplerate * 0.957;\
(multipying by 0.957 seems to give the most precise tuning)\
\
and then calculating c:\
\
f0 = f * inv_samplerate;\
if (f0 < 0.05) c = (f0 * pi); \
else c = tan(f0 * pi);\
\
Now I used 0.05 instead of 0.1, thats 0.05 * 44100\'a0\'a0= 2.2k instead of 4.4k. So, this is a bit more precise than 0.1, becuase around 3-4k it had a slight error, however, only noticeable on the analyzer when compared to the original version. This is still about two third of the logarithmic frequency scale, so it's quite a bit of a speed improvement. You can use either precision for both lowpass and highpass.\
\
For calculating tan(), you can take some quick sin() approximation, and use:\
\'a0\'a0tan(x)=sin(x)/sin(half_pi-x)\
\
There are many good pieces of code for that in the archive.\
\
I tried to make some 1/x based approximations for 1.0/tan(x), here is one:\
\
inline float tan_inv_approx(float x)\
\{\
\'a0\'a0\'a0\'a0float const two_div_pi = 2.0f/3.141592654f;\
\'a0\'a0\'a0\'a0if (x<0.5f) return 1.0f/x; \
\'a0\'a0\'a0\'a0else return 1.467f*(1.0f/x-two_div_pi);\
\}\nestcell \lastrow\nestrow
\pard\intbl\itap1\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \
\

\itap2\trowd \taflags0 \trgaph108\trleft-108 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clcbpat4 \clwWidth33055\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt100 \clpadl100 \clpadb100 \clpadr100 \gaph\cellx8640
\pard\intbl\itap2\pardeftab720\partightenfactor0
\cf0 \

\f1\fs26 \cf2 Optimization for Hipass:\
\
c = tan(pi * f / sample_rate);\
\
c = ( c + r ) * c;\
a1 = 1.0 / ( 1.0 + c );\
b1 = ( 1.0 - c );\
\
out(n) = ( a1 * out(n-1) + in - in(n-1) ) * b1;\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0
\f0\fs24 \cf0 \nestcell \lastrow\nestrow
\pard\intbl\itap1\pardeftab720\partightenfactor0
\cf0 \cell \lastrow\row
}